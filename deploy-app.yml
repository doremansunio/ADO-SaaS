# File: PlatformAutomation/templates/shared/deploy-app.yml
#
# Reusable template for deploying application packages to various target environments.
# This template abstracts the specific deployment logic based on the 'environmentType' parameter,
# allowing for flexible deployment to Azure App Services, On-Premise Windows/Linux, or Kubernetes/OpenShift.

parameters:
- name: environmentType # Specifies the type of deployment target (e.g., azureWebApp, onPremiseFCI, openShift).
  type: string
  displayName: 'Type of deployment environment'
- name: azureSubscription
  type: string
  displayName: 'Azure Service Connection Name (if deploying to Azure)'
  default: '' # Default to empty if not an Azure deployment.
- name: appServiceName
  type: string
  displayName: 'Name of the application service (Azure App Service name, K8s service name, etc.)'
  default: ''
- name: targetOS # Relevant for Azure WebApp (e.g., Linux/Windows).
  type: string
  default: ''
- name: appServicePlanName # Relevant for Azure App Service Environment deployments.
  type: string
  default: ''
- name: appServerName # Relevant for On-Premise FCI (Full Qualified Domain Name of a Windows machine).
  type: string
  default: ''
- name: winRmServiceConnection # Azure DevOps WinRM Service Connection for Windows servers.
  type: string
  default: ''
- name: sshServiceConnection # Azure DevOps SSH Service Connection for Linux servers.
  type: string
  default: ''
- name: remotePath # Remote deployment path on target server (Windows or Linux).
  type: string
  default: ''
- name: kubernetesServiceConnection # Azure DevOps Kubernetes Service Connection for K8s/OpenShift.
  type: string
  default: ''
- name: k8sNamespace # Kubernetes/OpenShift namespace for deployment.
  type: string
  default: ''
- name: imageName # Docker image name for container deployments.
  type: string
  default: ''
- name: imageTag # Docker image tag for container deployments.
  type: string
  default: ''
- name: backendPackagePath # Local path to the compiled application package artifact.
  type: string
  displayName: 'Path to the .NET backend package (e.g., $(Pipeline.Workspace)/BackendWebApp)'
- name: appUrlForTests # URL of the deployed application, used for post-deployment tests.
  type: string
  displayName: 'URL of the deployed application for functional tests'

steps:
# --------------------------------------------------------------------------------------
# Deployment Logic based on environmentType parameter
# --------------------------------------------------------------------------------------

# --- Azure WebApp (Linux/Windows) Deployment ---
- ${{ if eq(parameters.environmentType, 'azureWebApp') }}:
  - task: AzureWebApp@1
    displayName: 'Deploy to Azure App Service: ${{ parameters.appServiceName }}'
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      # Choose appType based on targetOS.
      appType: ${{ parameters.targetOS == 'Linux' && 'webAppLinux' || 'webApp' }}
      appName: ${{ parameters.appServiceName }}
      package: ${{ parameters.backendPackagePath }} # Path to the artifact to deploy.

# --- Azure App Service Environment (ASE) Deployment ---
- ${{ if eq(parameters.environmentType, 'azureAppServiceEnvironment') }}:
  - task: AzureWebApp@1
    displayName: 'Deploy to Azure App Service in ASE: ${{ parameters.appServiceName }} (Plan: ${{ parameters.appServicePlanName }})'
    inputs:
      azureSubscription: ${{ parameters.azureSubscription }}
      # Assumes Linux for ASE, adjust appType if deploying Windows app to ASE.
      appType: 'webAppLinux'
      appName: ${{ parameters.appServiceName }}
      package: ${{ parameters.backendPackagePath }}

# --- On-Premise Windows FCI (IIS Shared Configuration) Deployment ---
- ${{ if eq(parameters.environmentType, 'onPremiseFCI') }}:
  # NOTE: This part requires a Windows-based Azure DevOps Agent to execute.
  # The agent pool defined in the meta-pipeline and dotnet-ci-cd.yml must be a Windows pool.
  # WinRM service connection is crucial here for remote execution.
  - task: PowerShellOnTargetMachines@3
    displayName: 'Deploy to On-Premise Windows FCI: ${{ parameters.appServerName }}'
    inputs:
      Machines: ${{ parameters.appServerName }} # Target machine (e.g., FQDN of a cluster node).
      CredentialOption: 'Service Connection'
      serviceEndpoint: ${{ parameters.winRmServiceConnection }}
      ScriptType: 'Inline'
      InlineScript: |
        $remotePath = "${{ parameters.remotePath }}"
        $packageSourcePath = "$(Pipeline.Workspace)/BackendWebApp" # Path where artifact is downloaded.

        Write-Host "Cleaning and copying backend package to $remotePath on ${{ parameters.appServerName }}"
        # Remotely execute PowerShell commands to clean target directory and copy files.
        Invoke-Command -ComputerName "${{ parameters.appServerName }}" -Credential $cred {
            param($targetPath)
            if (Test-Path $targetPath) {
                Write-Host "Removing existing content from $targetPath"
                Remove-Item -Path $targetPath -Recurse -Force
            }
            Write-Host "Creating target directory $targetPath"
            New-Item -Path $targetPath -ItemType Directory -Force
        } -ArgumentList $remotePath

        Write-Host "Copying files from $packageSourcePath to $remotePath"
        Copy-Item -Path "$packageSourcePath\*" -Destination $remotePath -Recurse -Force

        Write-Host "Recycling Application Pool for site (assuming 'YourAppPoolName')"
        # IMPORTANT: Replace "YourAppPoolName" with the actual name of your IIS Application Pool
        # for this application. This should be configured in IIS.
        Invoke-Command -ComputerName "${{ parameters.appServerName }}" -Credential $cred {
            Import-Module WebAdministration
            # Check if the app pool exists before trying to recycle.
            if (Get-WebAppPoolState -Name "YourAppPoolName") {
                Write-Host "Recycling App Pool: YourAppPoolName"
                Recycle-WebAppPool -Name "YourAppPoolName"
            } else {
                Write-Warning "Application Pool 'YourAppPoolName' not found. Skipping recycle."
            }
        }

        Write-Host "Deployment to FCI node completed. Verify app pool recycled and site is up."
      # failOnStdErr: true # Uncomment if you want the task to fail on any stderr output.

# --- On-Premise Linux SSH Deployment ---
- ${{ if eq(parameters.environmentType, 'onPremiseLinuxSSH') }}:
  - task: SSH@0
    displayName: 'Clean Remote Deployment Path: ${{ parameters.remotePath }}'
    inputs:
      sshEndpoint: ${{ parameters.sshServiceConnection }}
      runOptions: 'commands'
      commands: |
        # Commands to clean the target directory on the Linux server.
        sudo rm -rf ${{ parameters.remotePath }}/*
        sudo mkdir -p ${{ parameters.remotePath }}
      failOnStdErr: true

  - task: CopyFilesOverSSH@0
    displayName: 'Copy .NET Backend to Remote Server'
    inputs:
      sshEndpoint: ${{ parameters.sshServiceConnection }}
      sourceFolder: ${{ parameters.backendPackagePath }}
      targetFolder: ${{ parameters.remotePath }}
      cleanTargetFolder: false # Already cleaned by previous SSH task.
      overwrite: true

  - task: SSH@0
    displayName: 'Restart .NET Backend (Systemd Service)'
    inputs:
      sshEndpoint: ${{ parameters.sshServiceConnection }}
      runOptions: 'commands'
      commands: |
        # Commands to stop, start, and check status of the application's systemd service.
        # Replace 'mydotnetapi.service' with your actual service name.
        sudo systemctl stop mydotnetapi.service || true # Stop (ignore if not running).
        sudo systemctl start mydotnetapi.service
        sudo systemctl status mydotnetapi.service --no-pager
      failOnStdErr: true

# --- OpenShift/Kubernetes Deployment ---
- ${{ if eq(parameters.environmentType, 'openShift') }}:
  - task: Kubernetes@1
    displayName: 'Deploy to OpenShift/Kubernetes: ${{ parameters.appServiceName }}'
    inputs:
      connectionType: 'Kubernetes Service Connection'
      kubernetesServiceConnection: ${{ parameters.kubernetesServiceConnection }}
      namespace: ${{ parameters.k8sNamespace }}
      command: 'apply' # Applies Kubernetes/OpenShift manifest files.
      arguments: '-f $(Build.SourcesDirectory)/k8s/dotnet-deployment.yaml -f $(Build.SourcesDirectory)/k8s/dotnet-service.yaml'
      # IMPORTANT: Ensure your Kubernetes YAML files (e.g., dotnet-deployment.yaml)
      # reference the image using the provided parameters:
      #   image: yourregistry.azurecr.io/${{ parameters.imageName }}:${{ parameters.imageTag }}

# --- Run Functional Tests (common step after any deployment) ---
- template: run-functional-tests.yml@self # Template to execute functional/smoke tests.
  parameters:
    appUrl: ${{ parameters.appUrlForTests }} # Pass the deployed application's URL for testing.