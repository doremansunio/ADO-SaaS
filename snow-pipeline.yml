# File: PlatformAutomation/meta-pipeline.yml
# This pipeline runs to onboard or update application CI/CD configurations.

name: $(Date:yyyyMMdd)$(Rev:.r) # Standard pipeline naming convention

trigger:
  branches:
    include:
      - main # Trigger on changes to the main branch of this repo

pr:
  branches:
    include:
      - main

parameters:
- name: appConfigFilePath
  displayName: 'Path to Application Configuration JSON'
  type: string
  default: 'configs/my-flexible-dotnet-api.json' # Default path for an example app config
  values:
  - 'configs/my-flexible-dotnet-api.json' # Example value, you'd add more for different apps

jobs:
- job: OnboardApplication
  displayName: 'Onboard/Update Application CI/CD'
  pool:
    name: Azure Pipelines # Use a Microsoft-hosted agent

  steps:
  - checkout: self # Checkout the PlatformAutomation repository

  - task: PowerShell@2
    displayName: 'Install Azure DevOps CLI Extension'
    inputs:
      targetType: 'inline'
      script: |
        az extension add --name azure-devops --yes
    env:
      AZURE_DEVOPS_EXT_PAT: $(System.AccessToken) # Use System.AccessToken for CLI authentication

  - task: PowerShell@2
    displayName: 'Read Application Configuration and Prepare Repository'
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop" # Stop on errors

        $appConfigFilePath = "${{ parameters.appConfigFilePath }}"
        Write-Host "Attempting to read application configuration from: $appConfigFilePath"

        if (-not (Test-Path $appConfigFilePath)) {
            Write-Error "Application configuration file not found at $appConfigFilePath"
            exit 1
        }

        $appConfig = Get-Content $appConfigFilePath | ConvertFrom-Json
        Write-Host "Successfully read application configuration for $($appConfig.appName)"

        # --- Set core pipeline variables from appConfig ---
        Write-Host "##vso[task.setvariable variable=appName]$($appConfig.appName)"
        Write-Host "##vso[task.setvariable variable=repoName]$($appConfig.repoName)"
        Write-Host "##vso[task.setvariable variable=solutionPath]$($appConfig.solutionPath)"
        Write-Host "##vso[task.setvariable variable=testProjectPath]$($appConfig.testProjectPath)"
        Write-Host "##vso[task.setvariable variable=techStack]$($appConfig.techStack)"
        Write-Host "##vso[task.setvariable variable=azureSubscriptionServiceConnection]$($appConfig.azureSubscriptionServiceConnection)"
        Write-Host "##vso[task.setvariable variable=agentPoolName]$($appConfig.agentPoolName)"
        Write-Host "##vso[task.setvariable variable=enableCI]$($appConfig.enableCI)"
        Write-Host "##vso[task.setvariable variable=enableCD]$($appConfig.enableCD)"
        Write-Host "##vso[task.setvariable variable=containerRegistryServiceConnection]$($appConfig.containerRegistryServiceConnection)"

        # --- Process environment-specific deployment options ---
        $environments = @("dev", "qa", "prod")
        foreach ($env in $environments) {
            $envConfig = $appConfig.environments.$env
            if ($envConfig) {
                $enabledDeploymentOption = $envConfig.deploymentOptions | Where-Object { $_.enabled } | Select-Object -First 1

                if ($enabledDeploymentOption) {
                    $deploymentType = $enabledDeploymentOption.type
                    Write-Host "##vso[task.setvariable variable=${env}DeploymentType]$deploymentType"
                    Write-Host "Set pipeline variable '${env}DeploymentType' to: $deploymentType"

                    foreach ($prop in $enabledDeploymentOption.PSObject.Properties) {
                        if ($prop.Name -ne 'type' -and $prop.Name -ne 'enabled') {
                            Write-Host "##vso[task.setvariable variable=${env}$($prop.Name)]$($prop.Value)"
                            Write-Host "Set pipeline variable '${env}$($prop.Name)' to: $($prop.Value)"
                        }
                    }
                } else {
                    Write-Host "##vso[task.setvariable variable=${env}DeploymentType]none"
                    Write-Host "No deployment option enabled for environment: $env"
                }
            } else {
                Write-Host "No configuration found for environment: $env"
                Write-Host "##vso[task.setvariable variable=${env}DeploymentType]none"
            }
        }

        # --- Git Operations: Clone, Generate Files, Commit, Push ---
        $repoUrl = "https://$(System.CollectionUri)$(System.TeamProject)/_git/$(repoName)"
        $tempRepoPath = "$(Agent.TempDirectory)/$(repoName)"
        Write-Host "Cloning repository $repoUrl to $tempRepoPath"
        git config --global user.email "azuredevops@yourcompany.com"
        git config --global user.name "Azure DevOps Automation"
        git clone $repoUrl $tempRepoPath -b main # Assuming main branch

        Set-Location $tempRepoPath

        # Create .azuredevops directory if it doesn't exist
        $azureDevopsDir = Join-Path $tempRepoPath ".azuredevops"
        if (-not (Test-Path $azureDevopsDir)) {
            New-Item -ItemType Directory -Path $azureDevopsDir
            Write-Host "Created directory: $azureDevopsDir"
        }

        # Generate azure-pipelines.yml
        $pipelineYamlContent = @"
# File: .azuredevops/azure-pipelines.yml
# Generated by PlatformAutomation/meta-pipeline.yml - DO NOT EDIT MANUALLY
# To make changes, update configs/${{ parameters.appConfigFilePath | Split-Path -Leaf }} in the PlatformAutomation repo.

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - '*' # Trigger on any change to the app repo

resources:
  repositories:
    - repository: platform_templates # Alias for the PlatformAutomation repo
      type: git
      name: $(System.TeamProject)/PlatformAutomation # Adjust if your PlatformAutomation repo is in another project
      ref: main

extends:
  template: templates/dotnet-ci-cd.yml@platform_templates
  parameters:
    appName: '$(appName)'
    repoName: '$(repoName)'
    solutionPath: '$(solutionPath)'
    testProjectPath: '$(testProjectPath)'
    techStack: '$(techStack)'
    azureSubscriptionServiceConnection: '$(azureSubscriptionServiceConnection)'
    agentPoolName: '$(agentPoolName)'
    containerRegistryServiceConnection: '$(containerRegistryServiceConnection)'
    enableCI: '$(enableCI)'
    enableCD: '$(enableCD)'

    # Dev Environment Params
    devDeploymentType: '$(devDeploymentType)'
    devAppServiceName: '$(devAppServiceName)'
    devResourceGroupName: '$(devResourceGroupName)'
    devAppUrlForTests: '$(devAppUrlForTests)'
    devAppServerName: '$(devAppServerName)'
    devWinRmServiceConnection: '$(devWinRmServiceConnection)'
    devRemotePath: '$(devRemotePath)'
    devK8sImageName: '$(devK8sImageName)'
    devK8sNamespace: '$(devK8sNamespace)'
    devK8sDeploymentName: '$(devK8sDeploymentName)'
    devK8sServiceConnection: '$(devK8sServiceConnection)'
    devK8sContainerPort: '$(devK8sContainerPort)'

    # QA Environment Params
    qaDeploymentType: '$(qaDeploymentType)'
    qaAppServiceName: '$(qaAppServiceName)'
    qaResourceGroupName: '$(qaResourceGroupName)'
    qaAppUrlForTests: '$(qaAppUrlForTests)'
    qaAppServerName: '$(qaAppServerName)'
    qaWinRmServiceConnection: '$(qaWinRmServiceConnection)'
    qaRemotePath: '$(qaRemotePath)'
    qaK8sImageName: '$(qaK8sImageName)'
    qaK8sNamespace: '$(qaK8sNamespace)'
    qaK8sDeploymentName: '$(qaK8sDeploymentName)'
    qaK8sServiceConnection: '$(qaK8sServiceConnection)'
    qaK8sContainerPort: '$(qaK8sContainerPort)'

    # Prod Environment Params
    prodDeploymentType: '$(prodDeploymentType)'
    prodAppServiceName: '$(prodAppServiceName)'
    prodResourceGroupName: '$(prodResourceGroupName)'
    prodAppUrlForTests: '$(prodAppUrlForTests)'
    prodAppServerName: '$(prodAppServerName)'
    prodWinRmServiceConnection: '$(prodWinRmServiceConnection)'
    prodRemotePath: '$(prodRemotePath)'
    prodK8sImageName: '$(prodK8sImageName)'
    prodK8sNamespace: '$(prodK8sNamespace)'
    prodK8sDeploymentName: '$(prodK8sDeploymentName)'
    prodK8sServiceConnection: '$(prodK8sServiceConnection)'
    prodK8sContainerPort: '$(prodK8sContainerPort)'
"@

        Set-Content -Path (Join-Path $azureDevopsDir "azure-pipelines.yml") -Value $pipelineYamlContent
        Write-Host "Generated .azuredevops/azure-pipelines.yml"

        # Create config directory if it doesn't exist
        $configDir = Join-Path $tempRepoPath "config"
        if (-not (Test-Path $configDir)) {
            New-Item -ItemType Directory -Path $configDir
            Write-Host "Created directory: $configDir"
        }

        # Generate params.json
        $paramsJsonContent = @{
            appName = $appConfig.appName;
            repoName = $appConfig.repoName;
            solutionPath = $appConfig.solutionPath;
            testProjectPath = $appConfig.testProjectPath;
            buildConfiguration = "Release"; # Default for params.json, can be overridden if needed
            appEnvironment = "Development"; # Default for params.json, intended to be set by environment var
            # Add any other config values the *application* needs at runtime/build-time
            # For example, if you want appUrlForTests also in params.json for direct app/script consumption:
            # devAppUrlForTests = $appConfig.environments.dev.deploymentOptions | Where-Object { $_.enabled } | Select-Object -ExpandProperty appUrlForTests
        } | ConvertTo-Json -Depth 5 -Compress

        Set-Content -Path (Join-Path $configDir "params.json") -Value $paramsJsonContent
        Write-Host "Generated config/params.json"

        # Commit and Push
        git add .
        git commit -m "chore(platform): Onboard/Update CI/CD pipeline for $(appName) [skip ci]" # skip ci to prevent trigger loops
        $PAT = "$(System.AccessToken)"
        $B64_PAT = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("PAT:$PAT"))
        $repoUrlWithAuth = $repoUrl -replace "https://", "https://oauth2:$($B64_PAT)@"
        git push $repoUrlWithAuth main
        Write-Host "Committed and pushed changes to $(repoName) main branch."

        # --- Create/Update Azure DevOps Pipeline Definition ---
        $pipelineName = "$(appName)-CI-CD"
        $projectUrl = "$(System.CollectionUri)$(System.TeamProject)"

        Write-Host "Checking for existing pipeline definition for $pipelineName..."
        try {
            $existingPipeline = az pipelines show --name "$pipelineName" --project "$(System.TeamProject)" --query "id" -o tsv --only-show-errors
            if ($existingPipeline) {
                Write-Host "Pipeline '$pipelineName' already exists (ID: $existingPipeline). Updating it."
                az pipelines update --name "$pipelineName" --yaml-path "$tempRepoPath/.azuredevops/azure-pipelines.yml" --repository "$repoName" --branch "main" --project "$(System.TeamProject)" --only-show-errors
            }
            else {
                Write-Host "Pipeline '$pipelineName' does not exist. Creating new pipeline."
                az pipelines create --name "$pipelineName" --yaml-path "$tempRepoPath/.azuredevops/azure-pipelines.yml" --repository "$repoName" --branch "main" --project "$(System.TeamProject)" --only-show-errors
            }
            Write-Host "Azure DevOps pipeline definition for '$pipelineName' is up-to-date."
        }
        catch {
            Write-Error "Failed to create/update Azure DevOps pipeline definition: $($_.Exception.Message)"
            exit 1
        }

        # --- Register KPI (Placeholder) ---
        # This is where you might make an API call to an internal system
        # to register that an application has been successfully onboarded/updated.
        Write-Host "Registering KPI for onboarded application $($appConfig.appName)... (Placeholder)"
    env:
      AZURE_DEVOPS_EXT_PAT: $(System.AccessToken) # Pass PAT for az CLI auth